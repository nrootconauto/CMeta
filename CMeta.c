/* Generated by re2c 1.1.1 on Wed Apr 22 13:52:27 2020 */
#line 1 "/home/clayton/projects/cMeta/CMeta.re.c"
#include "CMeta.h"
#include "string.h"
#include "util.h"
#include "ext/C_Unescaper/escaper.h"
CMetaInstance CMetaInstanceInit()
{
  CMetaInstance retVal;
  retVal.segments=NULL;
  retVal.inSegment=false;
  retVal.cbracketDepth=0;
  retVal.state=NULL;
  return retVal;
}
void CMetaRun(CMetaInstance *instance,CMetaBuffer *textStart)
{
  const char *start, *cutout,*YYMARKER=NULL;
 loop:
  ;
  const char *yyt1;
  
#line 24 "/home/clayton/projects/cMeta/CMeta.c"
{
	char yych;
	unsigned int yyaccept = 0;
	yych = *textStart->bufferPos;
	switch (yych) {
	case 0x00:	goto yy2;
	case '"':
	case '\'':	goto yy6;
	case '(':	goto yy8;
	case ')':	goto yy10;
	case '/':	goto yy12;
	case 'C':
		yyt1 = textStart->bufferPos;
		goto yy13;
	default:	goto yy4;
	}
yy2:
	++textStart->bufferPos;
#line 39 "/home/clayton/projects/cMeta/CMeta.re.c"
	{goto end;}
#line 45 "/home/clayton/projects/cMeta/CMeta.c"
yy4:
	++textStart->bufferPos;
yy5:
#line 33 "/home/clayton/projects/cMeta/CMeta.re.c"
	{goto loop;}
#line 51 "/home/clayton/projects/cMeta/CMeta.c"
yy6:
	++textStart->bufferPos;
	start = textStart->bufferPos - 1;
#line 40 "/home/clayton/projects/cMeta/CMeta.re.c"
	{goto stringStart;}
#line 57 "/home/clayton/projects/cMeta/CMeta.c"
yy8:
	++textStart->bufferPos;
#line 35 "/home/clayton/projects/cMeta/CMeta.re.c"
	{goto depthInc;}
#line 62 "/home/clayton/projects/cMeta/CMeta.c"
yy10:
	++textStart->bufferPos;
	start = textStart->bufferPos - 1;
	cutout = textStart->bufferPos;
#line 36 "/home/clayton/projects/cMeta/CMeta.re.c"
	{goto depthDec;}
#line 69 "/home/clayton/projects/cMeta/CMeta.c"
yy12:
	yyaccept = 0;
	yych = *(YYMARKER = ++textStart->bufferPos);
	switch (yych) {
	case '*':	goto yy14;
	case '/':	goto yy15;
	default:	goto yy5;
	}
yy13:
	yyaccept = 0;
	yych = *(YYMARKER = ++textStart->bufferPos);
	switch (yych) {
	case 'M':	goto yy18;
	default:	goto yy5;
	}
yy14:
	yych = *++textStart->bufferPos;
	switch (yych) {
	case '*':	goto yy21;
	default:	goto yy20;
	}
yy15:
	yych = *++textStart->bufferPos;
	switch (yych) {
	case '\n':	goto yy17;
	default:	goto yy15;
	}
yy17:
#line 37 "/home/clayton/projects/cMeta/CMeta.re.c"
	{goto loop;}
#line 100 "/home/clayton/projects/cMeta/CMeta.c"
yy18:
	yych = *++textStart->bufferPos;
	switch (yych) {
	case 'E':	goto yy22;
	default:	goto yy19;
	}
yy19:
	textStart->bufferPos = YYMARKER;
	if (yyaccept == 0) {
		goto yy5;
	} else {
		goto yy46;
	}
yy20:
	yych = *++textStart->bufferPos;
	switch (yych) {
	case '*':	goto yy23;
	default:	goto yy19;
	}
yy21:
	yych = *++textStart->bufferPos;
	switch (yych) {
	case '/':	goto yy19;
	default:	goto yy20;
	}
yy22:
	yych = *++textStart->bufferPos;
	switch (yych) {
	case 'T':	goto yy24;
	default:	goto yy19;
	}
yy23:
	yych = *++textStart->bufferPos;
	switch (yych) {
	case '/':	goto yy25;
	default:	goto yy19;
	}
yy24:
	yych = *++textStart->bufferPos;
	switch (yych) {
	case 'A':	goto yy27;
	default:	goto yy19;
	}
yy25:
	++textStart->bufferPos;
#line 38 "/home/clayton/projects/cMeta/CMeta.re.c"
	{goto loop;}
#line 148 "/home/clayton/projects/cMeta/CMeta.c"
yy27:
	yych = *++textStart->bufferPos;
	switch (yych) {
	case '_':	goto yy28;
	default:	goto yy19;
	}
yy28:
	yych = *++textStart->bufferPos;
	switch (yych) {
	case 'S':	goto yy29;
	default:	goto yy19;
	}
yy29:
	yych = *++textStart->bufferPos;
	switch (yych) {
	case 'E':	goto yy30;
	default:	goto yy19;
	}
yy30:
	yych = *++textStart->bufferPos;
	switch (yych) {
	case 'G':	goto yy31;
	default:	goto yy19;
	}
yy31:
	yych = *++textStart->bufferPos;
	switch (yych) {
	case 'M':	goto yy32;
	default:	goto yy19;
	}
yy32:
	yych = *++textStart->bufferPos;
	switch (yych) {
	case 'E':	goto yy33;
	default:	goto yy19;
	}
yy33:
	yych = *++textStart->bufferPos;
	switch (yych) {
	case 'N':	goto yy34;
	default:	goto yy19;
	}
yy34:
	yych = *++textStart->bufferPos;
	switch (yych) {
	case 'T':	goto yy35;
	default:	goto yy19;
	}
yy35:
	yych = *++textStart->bufferPos;
	switch (yych) {
	case '_':	goto yy36;
	default:	goto yy19;
	}
yy36:
	yych = *++textStart->bufferPos;
	switch (yych) {
	case 'S':	goto yy37;
	default:	goto yy19;
	}
yy37:
	yych = *++textStart->bufferPos;
	switch (yych) {
	case 'T':	goto yy38;
	default:	goto yy19;
	}
yy38:
	yych = *++textStart->bufferPos;
	switch (yych) {
	case 'A':	goto yy39;
	default:	goto yy19;
	}
yy39:
	yych = *++textStart->bufferPos;
	switch (yych) {
	case 'R':	goto yy40;
	default:	goto yy19;
	}
yy40:
	yych = *++textStart->bufferPos;
	switch (yych) {
	case 'T':	goto yy41;
	default:	goto yy19;
	}
yy41:
	yych = *++textStart->bufferPos;
	switch (yych) {
	case '\t':
	case '\n':
	case '\r':
	case ' ':	goto yy43;
	case '(':	goto yy45;
	case '/':	goto yy47;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy41;
	default:	goto yy19;
	}
yy43:
	yych = *++textStart->bufferPos;
	switch (yych) {
	case '\t':
	case '\n':
	case '\r':
	case ' ':	goto yy43;
	case '(':	goto yy45;
	case '/':	goto yy47;
	default:	goto yy19;
	}
yy45:
	++textStart->bufferPos;
yy46:
	cutout = yyt1;
	start = textStart->bufferPos;
#line 34 "/home/clayton/projects/cMeta/CMeta.re.c"
	{goto foundPossibleSeg;}
#line 325 "/home/clayton/projects/cMeta/CMeta.c"
yy47:
	yych = *++textStart->bufferPos;
	switch (yych) {
	case '*':	goto yy48;
	case '/':	goto yy49;
	default:	goto yy19;
	}
yy48:
	yych = *++textStart->bufferPos;
	switch (yych) {
	case '*':	goto yy52;
	default:	goto yy51;
	}
yy49:
	yych = *++textStart->bufferPos;
	switch (yych) {
	case '\n':	goto yy43;
	case '(':	goto yy53;
	case '/':	goto yy55;
	default:	goto yy49;
	}
yy51:
	yych = *++textStart->bufferPos;
	switch (yych) {
	case '*':	goto yy57;
	default:	goto yy19;
	}
yy52:
	yych = *++textStart->bufferPos;
	switch (yych) {
	case '/':	goto yy19;
	default:	goto yy51;
	}
yy53:
	yyaccept = 1;
	yych = *(YYMARKER = ++textStart->bufferPos);
	switch (yych) {
	case '\n':	goto yy43;
	case '(':	goto yy53;
	case '/':	goto yy55;
	default:	goto yy49;
	}
yy55:
	yych = *++textStart->bufferPos;
	switch (yych) {
	case '\n':	goto yy43;
	case '(':	goto yy53;
	case '*':	goto yy58;
	case '/':	goto yy55;
	default:	goto yy49;
	}
yy57:
	yych = *++textStart->bufferPos;
	switch (yych) {
	case '/':	goto yy43;
	default:	goto yy19;
	}
yy58:
	yych = *++textStart->bufferPos;
	switch (yych) {
	case '\n':	goto yy59;
	case '(':	goto yy53;
	case '*':	goto yy60;
	case '/':	goto yy55;
	default:	goto yy49;
	}
yy59:
	yych = *++textStart->bufferPos;
	switch (yych) {
	case '\t':
	case '\n':
	case '\r':
	case ' ':	goto yy43;
	case '(':	goto yy45;
	case '*':	goto yy57;
	case '/':	goto yy47;
	default:	goto yy19;
	}
yy60:
	yych = *++textStart->bufferPos;
	switch (yych) {
	case '\n':	goto yy59;
	case '(':	goto yy53;
	case '/':	goto yy55;
	default:	goto yy49;
	}
}
#line 41 "/home/clayton/projects/cMeta/CMeta.re.c"

 foundPossibleSeg:
  //no segments in segment
  if(!instance->inSegment)
    {
      instance->inSegment=true;
      instance->segmentDepth=instance->cbracketDepth++;
      CMetaSegment temp;
      temp.positionStart.pos=start-textStart->fileStart;
      temp.positionStart.cutoutPos=cutout-textStart->fileStart;
      cvector_push_back(instance->segments, temp); 
    }
  goto loop;
 depthInc:
  instance->cbracketDepth++;
  goto loop;
 depthDec:
  instance->cbracketDepth--;
  if(instance->cbracketDepth==instance->segmentDepth&&instance->inSegment)
    {
      //found the ending ")" of the segement
      size_t last=cvector_size(instance->segments)-1;
      //
      CMetaSegment *seg=&cvector_begin(instance->segments)[last];
      seg->positionEnd.pos=start-textStart->fileStart;
      seg->positionEnd.cutoutPos=cutout-textStart->fileStart;
      //
      size_t startPos=seg->positionStart.pos;
      size_t endPos=start-textStart->fileStart;
      seg->code=sdsnewlen(textStart->fileStart+startPos,endPos-startPos);
      //
      instance->inSegment=false;
    }
  goto loop;
 stringStart:
  textStart->bufferPos=start;
  CMetaProccessString(textStart);  
  goto loop;
 end:
  return;
}
typedef cvector_vector_type(sds) vec_sds;
sds CMetaTextToTemplate(const sds text, int templateNumber)
{
  const char *oldPtr=text;
  const char *ptr=oldPtr;
  sds retVal=sdscatfmt(sdsnew(""), "  const char *template%i[]={\n", templateNumber);
  while((ptr=strchr(oldPtr, '\n')))
    {
      size_t size=ptr-oldPtr;
      char buffer[size*4+1];
      sds temp=sdsnewlen(oldPtr, size); //FREED
      *unescapeString(temp, buffer)='\0';
      retVal=sdscatfmt(retVal, "    \"%s\", \n", buffer);
      sdsfree(temp);
      oldPtr=ptr+1;
    }
  retVal=sdscat(retVal, "  };\n");
  retVal=sdscatfmt(retVal, "  WriteTemplate(template%i, sizeof(template%i)/sizeof(const char *));\n", templateNumber, templateNumber);
  return retVal;
}

void CMetaWriteOut(const CMetaInstance *instance, const CMetaBuffer *buffer, const char *outputFile, const CMetaCompilerOptions *compilerOptions, const char *testSourceFile)
{
  char inputFileNameBuffer[4*strlen(buffer->fileName)+1];
  *unescapeString((uint8_t*)buffer->fileName, (uint8_t*)inputFileNameBuffer)='\0';
  char outputFileNameBuffer[4*strlen(outputFile)+1];
  *unescapeString((uint8_t*)outputFile, (uint8_t*)outputFileNameBuffer)='\0';
  //
  const char *template[]=
    {
     "#include <stdio.h>",
     "#include <string.h>",
     "const char *INPUT_FILE_NAME=\"%s\";",
     "const char *OUTPUT_FILE_NAME=\"%s\";",
     "FILE *OUTPUT_FILE;",
     "void WriteTemplate(const char *template[], size_t count) {",
     "  for(int i=0;i!=count;i++) {",
     "    fwrite(template[i], 1, strlen(template[i]), OUTPUT_FILE);",
     "    fwrite(\"\\n\", 1, 1, OUTPUT_FILE);",
     "  }",
     "}",
     "int main(int argc, const  char** argv) {",
     "  OUTPUT_FILE=fopen(OUTPUT_FILE_NAME, \"w\");",
     "%s",
     "  fclose(OUTPUT_FILE);",
     "  return 0;",
     "}"
    };
  //
  size_t startPos=0;
  const char *inlineTextPtr=buffer->fileStart;
  size_t segmentCount=cvector_size(instance->segments);
  sds extractedSource=sdsnew("");
  CMetaSegment *basePtr=cvector_begin(instance->segments);
  for(size_t currentSegment=0;currentSegment!=segmentCount;currentSegment++)
    {
      //
      const CMetaSegment *segPtr=&basePtr[currentSegment];
      //
      size_t outsideCodeStart=startPos;
      size_t outsideCodeEnd=segPtr->positionStart.cutoutPos;
      sds outsideCodeSegment=sdsnewlen(buffer->fileStart+outsideCodeStart, outsideCodeEnd-outsideCodeStart); //FREED
      sds codeSegment=CMetaTextToTemplate(outsideCodeSegment,currentSegment); //FREED
      sdsfree(outsideCodeSegment);
      //
      //
      const char *codeSliceStart=segPtr->positionStart.pos+buffer->fileStart;
      size_t codeSliceSize=segPtr->positionEnd.pos-segPtr->positionStart.pos;
      sds generateCode=sdsnewlen(codeSliceStart, codeSliceSize); //FREED
      codeSegment=sdscatfmt(codeSegment, "\n%s\n", generateCode);
      //
      extractedSource=sdscatsds(extractedSource, codeSegment);
      sdsfree(codeSegment);
      sdsfree(generateCode);
      //
      startPos=segPtr->positionEnd.cutoutPos;
    }
  sds lastOutsideCodeSegment=sdsnew(buffer->fileStart+startPos); //FREED
  sds templated=CMetaTextToTemplate(lastOutsideCodeSegment, segmentCount); //FREED
  extractedSource=sdscatsds(extractedSource, templated);
  sdsfree(lastOutsideCodeSegment);
  sdsfree(templated);
  
  //COMPILE
  sds compileCommands=sdsnew("cd /tmp/ &&"); //FREED
  sds options=sdsnew("");
  if(cvector_size(compilerOptions->options)!=0)
    {
      size_t count=cvector_size(compilerOptions->options);
      const char** basePtr=cvector_begin(compilerOptions->options);
      for(size_t index=0;index!=count;index++)
	{
	  options=sdscatfmt(options, "%s ", basePtr[index]);
	}
    }
  char *outName=tempnam(NULL, "c");
  sds absolutePath=CMetaMakeFileNameAboslute(sdsnew(testSourceFile));
  compileCommands=sdscatfmt(compileCommands, "%s -o %s %s %s && %s ", compilerOptions->compiler, outName, options, absolutePath, outName);
  free(outName);
  //
  sds filledOutTemplate=sdsnew(compilerOptions->includes); //FREED
  size_t templateLines=sizeof(template)/sizeof(const char *);
  vec_sds items=NULL;
  
  
  cvector_push_back(items, extractedSource); //extractedSource freed in loop
  cvector_push_back(items, sdsnew(outputFileNameBuffer)); //FREED in loop
  cvector_push_back(items, sdsnew(inputFileNameBuffer)); //FREED in loop
  for(int i=0;i!=templateLines;i++)
    {
      const char* line=template[i];
      if(strstr(line, "%s")!=NULL)
	{
	  sds item=*(cvector_end(items)-1); //FREED
	  filledOutTemplate=sdscatfmt(filledOutTemplate, line, item);
	  sdsfree(item); //FREED
	  cvector_pop_back(items);
	}
      else
	{
	  filledOutTemplate=sdscat(filledOutTemplate, line);
	}
      filledOutTemplate=sdscat(filledOutTemplate, "\n");
    }
  //
  //write to file
  
  FILE *outputSource=fopen(absolutePath, "w");
  if(outputSource!=NULL)
    {
      fwrite(filledOutTemplate, 1, sdslen(filledOutTemplate), outputSource);
      fclose(outputSource);
    }
  else
    {
      printf("Coudlnt open output file \"%f\" for writing.", absolutePath);
    }
  //compile
  system(compileCommands);
  //
  if(compilerOptions->deleteSourceAfterUse)
    remove(outputFile);
  sdsfree(absolutePath);
  sdsfree(filledOutTemplate);
  sdsfree(options);
  sdsfree(compileCommands);
}
